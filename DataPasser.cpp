#include <iostream>
#include <csignal>
#include <ctime>
#include <unistd.h>
#include <sys/time.h>

#include "DataPasser.h"


nlohmann::json jsonDataWeight; // Global variable to keep the latest jsone data ..


void DataPasser::SerialDataCallback(std::string& data)
{
    //Serial data received ....
    // std::cout<<"Serial data received..."<<std::endl;
    // std::cout<<data<<std::endl;
    collector->CollectData(data);
}

void  DataPasser::ConvertJson(ScaleData data)
{
    //Array to hold names of the weights ..
    //TODO: if the channel count become larger .. need to implement it dynamically..
    //      if MAX_CHANNELS changed change the WeigntName array accordingly.
    std::string WeigntName[] = {
        "WeightA",
        "WeightB",
        "WeightC",
        "WeightD",
        "WeightE",
        "WeightF",
        "WeightG",
        "WeightH",
        "WeightI",
        "WeightJ"
    };

    // This is the format of the JSON string generated by this function.
    // {
    //     "WeightA": 5100,
    //     "WeightB": 17100,
    //     "WeightC": 22100,
    //     "WeightD": 15100,
    //     "TotalWeight": 59400,
    //     "VALID" : true
    // }
    using json = nlohmann::json;
    
    // Convert ScaleData to JSON
    json jsonData;
    int sum{}; //Used to calculate the total weight.

    //Inerating through the number of channels, converting to JSON 
    //and calculation of the total weight.
    for (size_t i = 0; i < (size_t)channelCount; ++i) {
        jsonData[WeigntName[i]] = data.weight[i];
        sum += data.weight[i];
    }
    jsonData["TotalWeight"] = data.totalWeight; //Assign total weight.
    jsonData["VALID"] = (sum == data.totalWeight) ? true: false; //Verify the total weight with received weight.

    jsonDataWeight = jsonData; //Passigng data to to print..
}


void DataPasser::WeightDataCallBack(ScaleData data)
{
    //Decoded data received..
    // std::cout<<"Weight data received..."<<std::endl;
    // for (size_t i = 0; i < (size_t)channelCount; i++)
    // {
    //     std::cout<<"Weight : " << data.weight[i] <<"Kg" << std::endl;
    // }
    // std::cout<<"Total Weight : " << data.totalWeight << "Kg" << std::endl;

    ConvertJson(std::move(data));
}


bool DataPasser::Start()
{
    //Limit the maxmum number of channels to MAX_CHANNELS.
    if(channelCount > MAX_CHANNELS )
    {
        std::cout<<"Channel count is too large. The application will now exit."<<std::endl;
        return false;
    }
    
    //Register for serial data from serial port..
    if(serialComm->RegisterCallback(std::bind(&DataPasser::SerialDataCallback, this, std::placeholders::_1 )) == false)
    {
        std::cout<<"Error registering callback for serial communication. The application will now exit."<<std::endl;
    } 

    //Register for decoded data
    if(collector->RegisterDataNotification(std::bind(&DataPasser::WeightDataCallBack, this, std::placeholders::_1 ))== false)
    {
        std::cout<<"Error registering callback for data passing. The application will now exit."<<std::endl;
    }

    // Start Serial listening operation
    if(serialComm->ListenPort() == false)
    {
        std::cout<<"Error listening to port.."<<std::endl;
        return false;
    }

    //Set the JSON print timer.
    if(SetTimer(printIntervalSeconds) == false)
    {
        std::cout<<"Error setting the timer.."<<std::endl;
        return false;
    }
    
    return true;
}

void DataPasser::Stop()
{
    //Stop the operation of the serial listner..
    serialComm->StopListen();
}

// Handler function for the timer signal
void timerHandler(int signum) 
{
    if (signum == SIGALRM)
    {
        // Print the JSON data
        if(jsonDataWeight.empty())
        {
            std::cout << "No new data received." << std::endl;
        }
        else
        {
            std::cout << jsonDataWeight << std::endl;
            jsonDataWeight.clear();
        }
    }
}


bool DataPasser::SetTimer(int secondIntervel)
{
    // Set up the timer
    struct sigaction sa;
    sa.sa_handler = &timerHandler;
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sigaction(SIGALRM, &sa, nullptr);

    // Set up the timer interval for every 10 seconds)
    struct itimerval timer;
    timer.it_interval.tv_sec = secondIntervel;
    timer.it_interval.tv_usec = 0;
    timer.it_value.tv_sec = secondIntervel;
    timer.it_value.tv_usec = 0;

    // Start the timer
    if(setitimer(ITIMER_REAL, &timer, nullptr) == 0)
    {
        return true;
    }
    else
    {
        return false;
    }
}


DataPasser::~DataPasser()
{
    Stop();//Stop all the operations ...
    delete serialComm;
    delete collector;
}
